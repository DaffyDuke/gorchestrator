{"name":"Gorchestrator","tagline":"Orchestrator as a Service - A RESTful Concurrent orchestrator in GO","body":"![Logo](https://raw.githubusercontent.com/owulveryck/gorchestrator/webclient2/clients/web/htdocs/gorchestrator-160x160.png)\r\n\r\n# Abstract\r\n\r\nA simple orchestrator that takes and adjacency matrix as input.\r\n\r\nThis orchestrator acts as a webservice.\r\nThis means that you send a representation of your graph and nodes via an HTTP POST request to the engine, and:\r\n\r\n* It decomposes the workflow\r\n* Launch as many \"processes\" (actually goroutines) as nodes (see performances)\r\n* Launch a conductor that acts as a communication vector for the running nodes\r\n\r\nOaaS is micro service oriented. Which means that it does not actually run the artifact of the node. Instead, It calls another web service that acts as a proxy for the execution task. The proxy may implement drivers as needed, such as a `shell` driver, an `ansible` driver, `docker`, ...\r\n\r\nThe concurrency is implemented thanks to go routines (See this [post](http://blog.owulveryck.info/2015/12/02/orchestrate-a-digraph-with-goroutine-a-concurrent-orchestrator/) for more information about the implementation)\r\n\r\n## The Gorch\r\n\r\n`gorch` is the Graphical-Orchestration representation.\r\n\r\nIt is a JSON representation of the graph.\r\n\r\nIt is composed of and adjaceny matrix and a list of nodes.\r\n\r\n```JSON\r\n{\r\n    \"name\": \"string\",\r\n    \"state\": 0,\r\n    \"digraph\": [\r\n        0\r\n    ],\r\n    \"nodes\": [\r\n        {\r\n            \"id\": 0,\r\n            \"state\": 0,\r\n            \"name\": \"string\",\r\n            \"engine\": \"string\",\r\n            \"artifact\": \"string\",\r\n            \"args\": [\r\n                \"string\"\r\n            ]\r\n        }\r\n    ]\r\n\r\n}\r\n```\r\n\r\n## The tools\r\n\r\ngorchestrator is composed of :\r\n\r\n* orchestrator which is the main execution webservices\r\n* sample clients to POST and GET queries and to display it (see the `web client` for example)\r\n* an execution portal which is also a webservice aim to acutally run the engines and executes the artifacts.\r\n\r\n# Getting it up and running\r\n\r\nThe engine is written in pure go. The package is go-gettable. Assuming you have a GO environment up and running, the following tasks should be enough to enjoy the orchestrator:\r\n\r\n* `go get github.com/owulveryck/gorchestrator`\r\n* `cd $GOPATH/src/github.com/owulveryck/gorchestrator`\r\n* `go run`\r\n\r\nThen you can post a query as described in the example folder:\r\n\r\n```shell\r\n# curl -X POST -H 'Content-Type:application/json' -H 'Accept:application/json' -d @example.json -k http://localhost:8080/v1/tasks\r\n```\r\n\r\n# API\r\n\r\nThe REST API is in developement but nearly stable. It is self documented with swagger. \r\n\r\n## Apidoc\r\n\r\nThe api doc is viewable\r\n\r\n* live [here](http://blog.owulveryck.info/gorchestrator/swagger/) for api documentation.\r\n* In your own instance at [http://localhost:8080/apidocs/](http://localhost:8080/apidocs/)\r\n\r\n# AuthN and AuthZ\r\n\r\nThe implementation is in the roadmap, and will be based on `oauth2`\r\n\r\n# Performances\r\n\r\nI did a `test` file to bench the orchestrator engine (and only the engine) with the `go` mechanism. The example, is the simple one listed one my blog post.\r\n\r\nHere are the results on my chromebook (which is small, with only 2 Gb of RAM)\r\n\r\n```\r\norchestrator git:(master)go test -bench . -cpu 1\r\nPASS\r\nBenchmarkRun        3000            981423 ns/op\r\nok      github.com/owulveryck/gorchestrator/orchestrator        3.882s\r\n```\r\n\r\nWhich means that I can interpret and run 3000 times this digraph in 3.8s (excluding the actual execution time of the task)\r\n\r\n__Note__ : It is simply the execution workflow as all the nodes do not perform any action.\r\n","google":"UA-69673850-2","note":"Don't delete this file! It's used internally to help with page regeneration."}