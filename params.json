{"name":"Gorchestrator","tagline":"Orchestrator as a Service - A RESTful Concurrent orchestrator in GO","body":"# Abstract\r\n\r\nA simple orchestrator that takes and adjacency matrix as input.\r\n\r\nThis orchestrator is a webservice.\r\nThe concurrency is implemented thanks to go routines (See this [post](http://blog.owulveryck.info/2015/12/02/orchestrate-a-digraph-with-goroutine-a-concurrent-orchestrator/) for more information about the implementation)\r\n\r\n\r\n# Getting it up and running\r\n\r\n```\r\ngo get github.com/owulveryck/gorchestrator\r\n```\r\n\r\nthen \r\n\r\n```\r\ngo run main.go\r\n```\r\n\r\nIt should start a http server listening on port 8080.\r\n\r\n# API\r\n\r\nThe api is in developement and will be documented with swagger. The APIdoc will be included in the distribution.\r\n\r\n# AuthN and AuthZ\r\n\r\nThe implementation is in the roadmap, and will be based on `oauth2`\r\n\r\n# Performances\r\n\r\nI did a `test` file to bench the orchestrator engine with the `go` mechanism. The example, is the simple one listed one my blog post.\r\n\r\nHere are the results on my chromebook (which is small, with only 2 Gb of RAM)\r\n\r\n```\r\norchestrator git:(master)go test -bench . -cpu 1\r\nPASS\r\nBenchmarkRun        3000            981423 ns/op\r\nok      github.com/owulveryck/gorchestrator/orchestrator        3.882s\r\n```\r\n\r\nWhich means that I can interpret and run 3000 times this digraph in 3.8s (excluding the actual execution time of the task)\r\n\r\n__Note__ : It is simply the execution workflow as all the nodes do not perform any action.\r\n","google":"UA-69673850-2","note":"Don't delete this file! It's used internally to help with page regeneration."}